* **剑指Offer**
   * 面试题1：[赋值运算符函数](#赋值运算符函数)
   * 面试题2：[实现Singleton模式](#实现Singleton模式)
   * 面试题3：[数组中重复的数字](#数组中重复的数字)
   * 面试题4：[二维数组的查找](#二维数组的查找)
   * 面试题5：[替换空格](#替换空格)
   * 面试题6：[从头到尾打印链表](#从头到尾打印链表)
   * 面试题7：[重建二叉树](#重建二叉树)
   * 面试题8：[二叉树的下一个节点](#二叉树的下一个节点)
   * 面试题9：[用两个栈实现队列](#用两个栈实现队列)
   * 面试题10：[裴波那契数列](#裴波那契数列)
   * 面试题11：[旋转数组的最小数字](#旋转数组的最小数字)
   * 面试题12：[矩阵中的路径](#矩阵中的路径)
   * 面试题13：[机器人的运动范围](#机器人的运动范围)
   * 面试题14：[剪绳子](#剪绳子)
   * 面试题15：[二进制中1的个数](#二进制中1的个数)
   * 面试题16：[数值的整数次方](#数值的整数次方)
   * 面试题17：[打印从1到最大的n位数](#打印从1到最大的n位数)
   * 面试题18：[删除链表的节点](#删除链表的节点)
   * 面试题19：[正则表达式匹配](#正则表达式匹配)
   * 面试题20：[表示数值的字符串](#表示数值的字符串)
   * 面试题21：[调整数组顺序使奇数位于偶数前面](#调整数组顺序使奇数位于偶数前面)
   * 面试题22：[链表中倒数第k个节点](#链表中倒数第k个节点)
   * 面试题23：[链表中环的入口节点](#链表中环的入口节点)
   * 面试题24：[反转链表](#反转链表)
   * 面试题25：[合并两个排序的链表](#合并两个排序的链表)
   * 面试题26：[树的子结构](#树的子结构)
   * 面试题27：[二叉树的镜像](#二叉树的镜像)
   * 面试题28：[对称的二叉树](#对称的二叉树)
   * 面试题29：[顺时针打印矩阵](#顺时针打印矩阵)
   * 面试题30：[包含min函数的栈](#包含min函数的栈)
   * 面试题31：[栈的压入弹出序列](#栈的压入弹出序列)
   * 面试题32：[从上到下打印二叉树](#从上到下打印二叉树)
   * 面试题33：[二叉搜索树的后序遍历序列](#二叉搜索树的后序遍历序列)
   * 面试题34：[二叉树中和为某一值的路径](#二叉树中和为某一值的路径)
   * 面试题35：[复杂链表的复制](#复杂链表的复制)
   * 面试题36：[二叉搜索树与双向链表](#二叉搜索树与双向链表)
   * 面试题37：[序列化二叉树](#序列化二叉树)
   * 面试题38：[字符串的排列](#字符串的排列)
   * 面试题39：[数组中出现次数超过一半的数字](#数组中出现次数超过一半的数字)
   * 面试题40：[最小的k个数](#最小的k个数)
   * 面试题41：[数据流中的中位数](#数据流中的中位数)
   * 面试题42：[连续子数组的最大和](#连续子数组的最大和)
   * 面试题43：[1~n整数中1出现的次数](#1n整数中1出现的次数)
   * 面试题44：[数字序列中某一位的数字](#数字序列中某一位的数字)
   * 面试题45：[把数组排成最小的数](#把数组排成最小的数)
   * 面试题46：[把数字翻译成字符串](#把数字翻译成字符串)
   * 面试题47：[礼物的最大价值](#礼物的最大价值)
   * 面试题48：[最长不含重复字符的子字符串](#最长不含重复字符的子字符串)
   * 面试题49：[丑数](#丑数)
   * 面试题50：[第一个只出现一次的字符](#第一个只出现一次的字符)
   * 面试题51：[数组中的逆序对](#数组中的逆序对)
   * 面试题52：[两个链表的第一个公共节点](#两个链表的第一个公共节点)
   * 面试题53：[在排序数组中查找数字](#在排序数组中查找数字)
   * 面试题54：[二叉搜索树的第k大节点](#二叉搜索树的第k大节点)
   * 面试题55：[二叉树的深度](#二叉树的深度)
   * 面试题56：[数组中数字出现的次数](#数组中数字出现的次数)
   * 面试题57：[和为s的数字](#和为s的数字)
   * 面试题58：[翻转字符串](#翻转字符串)
   * 面试题59：[队列的最大值](#队列的最大值)
   * 面试题60：[n个骰子的点数](#n个骰子的点数)
   * 面试题61：[扑克牌中的顺子](#扑克牌中的顺子)
   * 面试题62：[圆圈中最后剩下的数字](#圆圈中最后剩下的数字)
   * 面试题63：[股票的最大利润](#股票的最大利润)
   * 面试题64：[求1~n的和](#求1n的和)
   * 面试题65：[不用加减乘除做加法](#不用加减乘除做加法)
   * 面试题66：[构建乘积数组](#构建乘积数组)
   
# 剑指Offer题解
## 赋值运算符函数

```
//先创建一个临时实例，然后交换临时实例和原来的实例
CMyString& CMyString::operator =(const CMyString& str)
{
	if (this != &str)
	{
		CMyString temp(str);
		
		char* pTemp = temp.pData_;
		temp.pData_ = pData_;
		pData_ = pTemp;
	}
	return *this;
}

```
## 实现Singleton模式

```
//第一种懒汉式单例
class SingleClass
{
public:
	static SingleClass* GetInstance()
	{
		if (!instance)
			instance = new SingleClass();
		return instance;
	}

private:
	SingleClass(){};
	static SingleClass *instance;
};

SingleClass * SingleClass::instance = NULL;

---------------------------------------------

//第二种局部静态变量单例
class SingleClass
{
private:
	SingleClass() { }
	SingleClass(const SingleClass &);
	SingleClass & operator = (const SingleClass &);
public:
	static SingleClass* GetInstance()
	{
		static SingleClass instance;
		return &instance;
		//返回指针。返回引用的话，因为外部可能Singleton singleton = Singleton :: GetInstance();产生一次拷贝
	}
};


```

## 数组中重复的数字

```
//题目描述：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。


```

## 二维数组的查找
## 替换空格
## 从头到尾打印链表
## 重建二叉树
## 二叉树的下一个节点
## 用两个栈实现队列
## 裴波那契数列
## 旋转数组的最小数字
## 矩阵中的路径
## 机器人的运动范围
## 剪绳子
## 二进制中1的个数
## 数值的整数次方
## 打印从1到最大的n位数
## 删除链表的节点
## 正则表达式匹配
## 表示数值的字符串
## 调整数组顺序使奇数位于偶数前面
## 链表中倒数第k个节点
## 链表中环的入口节点
## 反转链表
## 合并两个排序的链表
## 树的子结构
## 二叉树的镜像
## 对称的二叉树
## 顺时针打印矩阵
## 包含min函数的栈
## 栈的压入弹出序列
## 从上到下打印二叉树
## 二叉搜索树的后序遍历序列
## 二叉树中和为某一值的路径
## 复杂链表的复制
## 二叉搜索树与双向链表
## 序列化二叉树
## 字符串的排列
## 数组中出现次数超过一半的数字
## 最小的k个数
## 数据流中的中位数
## 连续子数组的最大和
## 1~n整数中1出现的次数
## 数字序列中某一位的数字
## 把数组排成最小的数
## 把数字翻译成字符串
## 礼物的最大价值
## 最长不含重复字符的子字符串
## 丑数
## 第一个只出现一次的字符
## 数组中的逆序对
## 两个链表的第一个公共节点
## 在排序数组中查找数字
## 二叉搜索树的第k大节点
## 二叉树的深度
## 数组中数字出现的次数
## 和为s的数字
## 翻转字符串
## 队列的最大值
## n个骰子的点数
## 扑克牌中的顺子
## 圆圈中最后剩下的数字
## 股票的最大利润
## 求1~n的和
## 不用加减乘除做加法
## 构建乘积数组
